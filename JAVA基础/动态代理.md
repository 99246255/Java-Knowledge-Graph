#动态代理

## JDK动态代理
JDK动态代理所用到的代理类在程序调用到代理类对象时才由JVM真正创建，JVM根据传进来的业务实现类对象以及方法名，动态地创建了一个代理类的class文件并被字节码引擎执行，然后通过该代理类对象进行方法调用

JDK动态代理的代理对象在创建时，需要使用业务实现类所实现的接口作为参数（因为在后面代理方法时需要根据接口内的方法名进行调用）。如果业务实现类是没有实现接口而是直接定义业务方法的话，就无法使用JDK动态代理了。并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代理的（因为无法被调用）。

只能对接口进行动态代理，有一定的局限性（原因：单继承，生成的类extends Proxy)

## Cglib动态代理
cglib是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理。

cglib生成代理是通过字节码生成的子类作为代理类，因此不能对private final方法代理；

## 对比
CGLib动态代理创建代理实例速度慢，但是运行速度快；

JDK动态代理创建实例速度快，但是运行速度慢。

如果实例是单例的，推荐使用CGLib方式动态代理，反之则使用JDK方式进行动态代理。

Spring的实例默认是单例，所以这时候使用CGLib性能高。 

Spring AOP如果实现了接口用jdk动态代理，没有接口则用CGLIB